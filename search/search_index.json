{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"subtitles-translator \u00b6 Automatic subtitles translation with a local neural machine translation model. No third-party service required: the translation is done locally with small but efficient neural network models. Original movie in French Output of automatic translation Note Screenshots are taken from Bon voyage , a short French language propaganda film made by Alfred Hitchcock for the British Ministry of Information. This film is now in the Public Domain.","title":"Overview"},{"location":"#subtitles-translator","text":"Automatic subtitles translation with a local neural machine translation model. No third-party service required: the translation is done locally with small but efficient neural network models. Original movie in French Output of automatic translation Note Screenshots are taken from Bon voyage , a short French language propaganda film made by Alfred Hitchcock for the British Ministry of Information. This film is now in the Public Domain.","title":"subtitles-translator"},{"location":"available_languages/","text":"Note These language codes are used to import opus-mt model finetuned by Helsinki University. See full list of available languages/models here: https://huggingface.co/Helsinki-NLP Codes for available languages \u00b6 Language Code english en french fr spanish es german de russian ru arabic ar hindi hi italian it chinese zh dutch nl ```","title":"Available languages"},{"location":"available_languages/#codes-for-available-languages","text":"Language Code english en french fr spanish es german de russian ru arabic ar hindi hi italian it chinese zh dutch nl ```","title":"Codes for available languages"},{"location":"cli_reference/","text":"translate_subtitles_cli () \u00b6 Command Line Interface for Neural Subtitles Translation. Parameters: Name Type Description Default -h -- help Show CLI help message required -i -- input Path to the input movie (if ends with .mp4) or srt file (if ends with .srt) containing subtitles to be translated required -o -- output Path to the output movie (if ends with .mp4 and input is a movie) or srt file (if ends with .srt) containing translated subtitles required -s -- source Code for the language of source subtitles (the source MP4 must only contain one track of subtitles) required -t -- target Code for the target language after translation. required Example With the following command, subtitles from 'video.mp4' will be extracted and translated from 'french' to 'english'. The video containing translated subtitles will be saved as 'translated_video.mp4': subtitles_translator -i video.mp4 -o translated_video.mp4 -s fr -t en Source code in subtitles_translator/cli.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def translate_subtitles_cli () -> None : \"\"\"Command Line Interface for Neural Subtitles Translation. Parameters: -h (--help): Show CLI help message -i (--input): Path to the input movie (if ends with .mp4) or srt file (if ends with .srt) containing subtitles to be translated -o (--output): Path to the output movie (if ends with .mp4 and input is a movie) or srt file (if ends with .srt) containing translated subtitles -s (--source): Code for the language of source subtitles (the source MP4 must only contain one track of subtitles) -t (--target): Code for the target language after translation. Example: With the following command, subtitles from 'video.mp4' will be extracted and translated from 'french' to 'english'. The video containing translated subtitles will be saved as 'translated_video.mp4': ```shell subtitles_translator -i video.mp4 -o translated_video.mp4 -s fr -t en ``` \"\"\" parser = argparse . ArgumentParser ( description = \"Translate the subtitles of the source movie and save a new movie file with translated subtitles.\" ) parser . add_argument ( \"-i\" , \"--input\" , type = str , required = True , help = ( \"path to the input movie (if ends with .mp4) or srt files (if ends with .srt) containing subtitles to be\" \" translated\" ), ) parser . add_argument ( \"-o\" , \"--output\" , type = str , required = True , help = ( \"desired path to the output movie (if ends with .mp4 and input is a movie) or srt files (if ends with .srt)\" \" containing translated subtitles\" ), ) parser . add_argument ( \"-s\" , \"--source\" , type = str , required = True , help = \"language of the input subtitles (source language)\" ) parser . add_argument ( \"-t\" , \"--target\" , type = str , required = True , help = \"target language\" ) args = parser . parse_args () if args . input . endswith ( \".mp4\" ): source_srt = extract_srt ( args . input ) . split ( \" \\n \" ) elif args . input . endswith ( \".srt\" ): if args . output . endswith ( \".mp4\" ): raise ValueError ( \"MP4 output file inconsistent with SRT file input.\" ) with open ( args . input , \"r+\" ) as srt_file : source_srt = srt_file . read () . splitlines () else : raise ValueError ( \"Input file format not supported.\" ) source_language = AvailableLanguages ( args . source ) target_language = AvailableLanguages ( args . target ) translator = Translator ( source_language = source_language , target_language = target_language ) subtitles = Subtitles ( source_srt ) translator . translate_subtitles ( subtitles ) if args . output . endswith ( \".mp4\" ): subtitles . save_srt () insert_srt ( args . input , args . output , \"translated.srt\" ) elif args . output . endswith ( \".srt\" ): subtitles . save_srt ( args . output ) else : raise ValueError ( \"Input file format not supported.\" )","title":"Command Line Interface"},{"location":"cli_reference/#subtitles_translator.cli.translate_subtitles_cli","text":"Command Line Interface for Neural Subtitles Translation. Parameters: Name Type Description Default -h -- help Show CLI help message required -i -- input Path to the input movie (if ends with .mp4) or srt file (if ends with .srt) containing subtitles to be translated required -o -- output Path to the output movie (if ends with .mp4 and input is a movie) or srt file (if ends with .srt) containing translated subtitles required -s -- source Code for the language of source subtitles (the source MP4 must only contain one track of subtitles) required -t -- target Code for the target language after translation. required Example With the following command, subtitles from 'video.mp4' will be extracted and translated from 'french' to 'english'. The video containing translated subtitles will be saved as 'translated_video.mp4': subtitles_translator -i video.mp4 -o translated_video.mp4 -s fr -t en Source code in subtitles_translator/cli.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def translate_subtitles_cli () -> None : \"\"\"Command Line Interface for Neural Subtitles Translation. Parameters: -h (--help): Show CLI help message -i (--input): Path to the input movie (if ends with .mp4) or srt file (if ends with .srt) containing subtitles to be translated -o (--output): Path to the output movie (if ends with .mp4 and input is a movie) or srt file (if ends with .srt) containing translated subtitles -s (--source): Code for the language of source subtitles (the source MP4 must only contain one track of subtitles) -t (--target): Code for the target language after translation. Example: With the following command, subtitles from 'video.mp4' will be extracted and translated from 'french' to 'english'. The video containing translated subtitles will be saved as 'translated_video.mp4': ```shell subtitles_translator -i video.mp4 -o translated_video.mp4 -s fr -t en ``` \"\"\" parser = argparse . ArgumentParser ( description = \"Translate the subtitles of the source movie and save a new movie file with translated subtitles.\" ) parser . add_argument ( \"-i\" , \"--input\" , type = str , required = True , help = ( \"path to the input movie (if ends with .mp4) or srt files (if ends with .srt) containing subtitles to be\" \" translated\" ), ) parser . add_argument ( \"-o\" , \"--output\" , type = str , required = True , help = ( \"desired path to the output movie (if ends with .mp4 and input is a movie) or srt files (if ends with .srt)\" \" containing translated subtitles\" ), ) parser . add_argument ( \"-s\" , \"--source\" , type = str , required = True , help = \"language of the input subtitles (source language)\" ) parser . add_argument ( \"-t\" , \"--target\" , type = str , required = True , help = \"target language\" ) args = parser . parse_args () if args . input . endswith ( \".mp4\" ): source_srt = extract_srt ( args . input ) . split ( \" \\n \" ) elif args . input . endswith ( \".srt\" ): if args . output . endswith ( \".mp4\" ): raise ValueError ( \"MP4 output file inconsistent with SRT file input.\" ) with open ( args . input , \"r+\" ) as srt_file : source_srt = srt_file . read () . splitlines () else : raise ValueError ( \"Input file format not supported.\" ) source_language = AvailableLanguages ( args . source ) target_language = AvailableLanguages ( args . target ) translator = Translator ( source_language = source_language , target_language = target_language ) subtitles = Subtitles ( source_srt ) translator . translate_subtitles ( subtitles ) if args . output . endswith ( \".mp4\" ): subtitles . save_srt () insert_srt ( args . input , args . output , \"translated.srt\" ) elif args . output . endswith ( \".srt\" ): subtitles . save_srt ( args . output ) else : raise ValueError ( \"Input file format not supported.\" )","title":"translate_subtitles_cli()"},{"location":"ffmpeg_utils_reference/","text":"Binding function to use FFmpeg. This module provides Python binding functions to extract/insert subtitles to/from SRT files using FFmpeg. extract_srt ( video_path ) \u00b6 Use FFmpeg to extract subtitles in SRT format. Only the first subtitles track is extracted. Parameters: Name Type Description Default video_path str Path to the movie file required Returns: Name Type Description str str Full subtitles in srt format Source code in subtitles_translator/ffmpeg_utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def extract_srt ( video_path : str ) -> str : \"\"\"Use FFmpeg to extract subtitles in SRT format. Only the first subtitles track is extracted. Args: video_path (str): Path to the movie file Returns: str: Full subtitles in srt format \"\"\" # Use subprocess to call FFmpeg CLI out = sp . run ([ \"ffmpeg\" , \"-i\" , video_path , \"-map\" , \"s:0\" , \"-f\" , \"srt\" , \"-\" ], capture_output = True , text = True ) return out . stdout insert_srt ( video_path , output_path , srt_path ) \u00b6 Use FFmpeg to insert a new subtitles track. Parameters: Name Type Description Default video_path str Path to the source movie file required output_path str Desired path to the output movie file with new subtitles required srt_path str Path to the SRT subtitles file required Source code in subtitles_translator/ffmpeg_utils.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def insert_srt ( video_path : str , output_path : str , srt_path : str ) -> None : \"\"\"Use FFmpeg to insert a new subtitles track. Args: video_path (str): Path to the source movie file output_path (str): Desired path to the output movie file with new subtitles srt_path (str): Path to the SRT subtitles file \"\"\" # ffmpeg convert SRT (SubRip) to MP4-compliant subtitles with -c:s mov_text sp . run ( [ \"ffmpeg\" , \"-i\" , video_path , \"-f\" , \"srt\" , \"-i\" , srt_path , \"-map\" , \"0:0\" , \"-map\" , \"0:1\" , \"-map\" , \"1:0\" , \"-c:v\" , \"copy\" , \"-c\" , \"copy\" , \"-c:s\" , \"mov_text\" , output_path , ] )","title":"FFmpeg utils"},{"location":"ffmpeg_utils_reference/#subtitles_translator.ffmpeg_utils.extract_srt","text":"Use FFmpeg to extract subtitles in SRT format. Only the first subtitles track is extracted. Parameters: Name Type Description Default video_path str Path to the movie file required Returns: Name Type Description str str Full subtitles in srt format Source code in subtitles_translator/ffmpeg_utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def extract_srt ( video_path : str ) -> str : \"\"\"Use FFmpeg to extract subtitles in SRT format. Only the first subtitles track is extracted. Args: video_path (str): Path to the movie file Returns: str: Full subtitles in srt format \"\"\" # Use subprocess to call FFmpeg CLI out = sp . run ([ \"ffmpeg\" , \"-i\" , video_path , \"-map\" , \"s:0\" , \"-f\" , \"srt\" , \"-\" ], capture_output = True , text = True ) return out . stdout","title":"extract_srt()"},{"location":"ffmpeg_utils_reference/#subtitles_translator.ffmpeg_utils.insert_srt","text":"Use FFmpeg to insert a new subtitles track. Parameters: Name Type Description Default video_path str Path to the source movie file required output_path str Desired path to the output movie file with new subtitles required srt_path str Path to the SRT subtitles file required Source code in subtitles_translator/ffmpeg_utils.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def insert_srt ( video_path : str , output_path : str , srt_path : str ) -> None : \"\"\"Use FFmpeg to insert a new subtitles track. Args: video_path (str): Path to the source movie file output_path (str): Desired path to the output movie file with new subtitles srt_path (str): Path to the SRT subtitles file \"\"\" # ffmpeg convert SRT (SubRip) to MP4-compliant subtitles with -c:s mov_text sp . run ( [ \"ffmpeg\" , \"-i\" , video_path , \"-f\" , \"srt\" , \"-i\" , srt_path , \"-map\" , \"0:0\" , \"-map\" , \"0:1\" , \"-map\" , \"1:0\" , \"-c:v\" , \"copy\" , \"-c\" , \"copy\" , \"-c:s\" , \"mov_text\" , output_path , ] )","title":"insert_srt()"},{"location":"how_to/","text":"Note Please note that the current version only supports MP4 video files (MKV support coming soon). Your MP4 must contain only one subtitles track, which will be translated and replaced in a new MP4 file. Note You will have to use codes to specify source and target languages. You can find them here: Available Languages . Complete CLI reference is available here: CLI reference MP4 to MP4 \u00b6 With the following command, subtitles from video.mp4 will be extracted and translated from french to english . The video containing translated subtitles will be saved as translated_video.mp4 : subtitles_translator -i video.mp4 -o translated_video.mp4 -s fr -t en MP4 to SRT \u00b6 With the following command, subtitles from video.mp4 will be extracted and translated from french to english . Translated subtitles will be saved as translated.srt . subtitles_translator -i video.mp4 -o translated.srt -s fr -t en SRT to SRT \u00b6 With the following command, subtitles contained in the SRT file source.srt will be translated from french to english . Translated subtitles will be saved as translated.srt . subtitles_translator -i source.srt -o translated.srt -s fr -t en","title":"How-to guide"},{"location":"how_to/#mp4-to-mp4","text":"With the following command, subtitles from video.mp4 will be extracted and translated from french to english . The video containing translated subtitles will be saved as translated_video.mp4 : subtitles_translator -i video.mp4 -o translated_video.mp4 -s fr -t en","title":"MP4 to MP4"},{"location":"how_to/#mp4-to-srt","text":"With the following command, subtitles from video.mp4 will be extracted and translated from french to english . Translated subtitles will be saved as translated.srt . subtitles_translator -i video.mp4 -o translated.srt -s fr -t en","title":"MP4 to SRT"},{"location":"how_to/#srt-to-srt","text":"With the following command, subtitles contained in the SRT file source.srt will be translated from french to english . Translated subtitles will be saved as translated.srt . subtitles_translator -i source.srt -o translated.srt -s fr -t en","title":"SRT to SRT"},{"location":"installation/","text":"Installation \u00b6 Subtitles Translator is available as subtitles_translator on PyPI: pip install subtitles_translator You'll also need to install ffmpeg , which is available from most package managers: # on macOS using Homebrew (https://brew.sh/) brew install ffmpeg # on Windows using Chocolatey (https://chocolatey.org/) choco install ffmpeg # on Ubuntu or Debian sudo apt update && sudo apt install ffmpeg","title":"Installation"},{"location":"installation/#installation","text":"Subtitles Translator is available as subtitles_translator on PyPI: pip install subtitles_translator You'll also need to install ffmpeg , which is available from most package managers: # on macOS using Homebrew (https://brew.sh/) brew install ffmpeg # on Windows using Chocolatey (https://chocolatey.org/) choco install ffmpeg # on Ubuntu or Debian sudo apt update && sudo apt install ffmpeg","title":"Installation"},{"location":"subtitles_reference/","text":"Subtitles \u00b6 From a raw FFmpeg extraction, process the text and translate it using a given Translator object. Parameters: Name Type Description Default raw_subtitles list [ str ] Subtitles line by line required sub_format str sub_format of the extracted subtitles. Defaults to \"srt\". 'srt' Source code in subtitles_translator/subtitles.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Subtitles : \"\"\"From a raw FFmpeg extraction, process the text and translate it using a given Translator object. Args: raw_subtitles (list[str]): Subtitles line by line sub_format (str, optional): sub_format of the extracted subtitles. Defaults to \"srt\". \"\"\" def __init__ ( self , raw_subtitles : list [ str ], sub_format : str = \"srt\" ) -> None : self . raw_subtitles = raw_subtitles self . sub_format = sub_format self . full_text_lines : list [ str ] = [] self . aggregated_text_lines : list [ str ] = [] self . aggregated_dico_lines : dict [ str , list [ list ]] = {} self . build_aggregated_dico () def build_aggregated_dico ( self ) -> None : \"\"\"After converting raw extraction to list of lines, aggregates and clean lines in order to be able to translate them. When two lines are combined, both indexes are saved in order to replace each line at the end. \"\"\" seen_i = set () n = len ( self . raw_subtitles ) for i , line in enumerate ( self . raw_subtitles ): self . full_text_lines . append ( line ) if i in seen_i or \"-->\" in line : continue agg_line = \"\" if i < n - 1 and self . raw_subtitles [ i + 1 ] == \"\" : agg_line += line seen_i . add ( i ) self . aggregated_text_lines . append ( agg_line ) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i ]] # the following condition means that we are on the second part of a two lines subtitle text if i > 0 and i < n - 2 and self . raw_subtitles [ i + 2 ] == \"\" and self . raw_subtitles [ i - 1 ] != \"\" : seen_i . add ( i ) seen_i . add ( i + 1 ) agg_line += line + \" \" + self . raw_subtitles [ i + 1 ] self . aggregated_text_lines . append ( self . raw_subtitles [ i + 1 ]) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i , i + 1 ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i , i + 1 ]] def save_srt ( self , path : str | os . PathLike = \"translated.srt\" ) -> None : \"\"\"Save current subtitles into an srt files. If translate_subtitles was called before, this results in a translated srt file. Args: path (str | os.PathLike, optional): Path to the target SRT file. Defaults to \"translated.srt\". It is always saved, it is used to put back subtitles with FFmpeg. \"\"\" with open ( path , \"w\" , encoding = \"utf-8\" ) as file : for line in self . full_text_lines : # in Python we need to write blank lines manually (those in full_text_lines are skipped by default) if line == \"\" : file . write ( \" \\n \" ) else : file . write ( line ) file . write ( \" \\n \" ) build_aggregated_dico () \u00b6 After converting raw extraction to list of lines, aggregates and clean lines in order to be able to translate them. When two lines are combined, both indexes are saved in order to replace each line at the end. Source code in subtitles_translator/subtitles.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def build_aggregated_dico ( self ) -> None : \"\"\"After converting raw extraction to list of lines, aggregates and clean lines in order to be able to translate them. When two lines are combined, both indexes are saved in order to replace each line at the end. \"\"\" seen_i = set () n = len ( self . raw_subtitles ) for i , line in enumerate ( self . raw_subtitles ): self . full_text_lines . append ( line ) if i in seen_i or \"-->\" in line : continue agg_line = \"\" if i < n - 1 and self . raw_subtitles [ i + 1 ] == \"\" : agg_line += line seen_i . add ( i ) self . aggregated_text_lines . append ( agg_line ) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i ]] # the following condition means that we are on the second part of a two lines subtitle text if i > 0 and i < n - 2 and self . raw_subtitles [ i + 2 ] == \"\" and self . raw_subtitles [ i - 1 ] != \"\" : seen_i . add ( i ) seen_i . add ( i + 1 ) agg_line += line + \" \" + self . raw_subtitles [ i + 1 ] self . aggregated_text_lines . append ( self . raw_subtitles [ i + 1 ]) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i , i + 1 ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i , i + 1 ]] save_srt ( path = 'translated.srt' ) \u00b6 Save current subtitles into an srt files. If translate_subtitles was called before, this results in a translated srt file. Parameters: Name Type Description Default path str | os . PathLike Path to the target SRT file. Defaults to \"translated.srt\". It is always saved, it is used to put back subtitles with FFmpeg. 'translated.srt' Source code in subtitles_translator/subtitles.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def save_srt ( self , path : str | os . PathLike = \"translated.srt\" ) -> None : \"\"\"Save current subtitles into an srt files. If translate_subtitles was called before, this results in a translated srt file. Args: path (str | os.PathLike, optional): Path to the target SRT file. Defaults to \"translated.srt\". It is always saved, it is used to put back subtitles with FFmpeg. \"\"\" with open ( path , \"w\" , encoding = \"utf-8\" ) as file : for line in self . full_text_lines : # in Python we need to write blank lines manually (those in full_text_lines are skipped by default) if line == \"\" : file . write ( \" \\n \" ) else : file . write ( line ) file . write ( \" \\n \" )","title":"Subtitles Class"},{"location":"subtitles_reference/#subtitles_translator.subtitles.Subtitles","text":"From a raw FFmpeg extraction, process the text and translate it using a given Translator object. Parameters: Name Type Description Default raw_subtitles list [ str ] Subtitles line by line required sub_format str sub_format of the extracted subtitles. Defaults to \"srt\". 'srt' Source code in subtitles_translator/subtitles.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Subtitles : \"\"\"From a raw FFmpeg extraction, process the text and translate it using a given Translator object. Args: raw_subtitles (list[str]): Subtitles line by line sub_format (str, optional): sub_format of the extracted subtitles. Defaults to \"srt\". \"\"\" def __init__ ( self , raw_subtitles : list [ str ], sub_format : str = \"srt\" ) -> None : self . raw_subtitles = raw_subtitles self . sub_format = sub_format self . full_text_lines : list [ str ] = [] self . aggregated_text_lines : list [ str ] = [] self . aggregated_dico_lines : dict [ str , list [ list ]] = {} self . build_aggregated_dico () def build_aggregated_dico ( self ) -> None : \"\"\"After converting raw extraction to list of lines, aggregates and clean lines in order to be able to translate them. When two lines are combined, both indexes are saved in order to replace each line at the end. \"\"\" seen_i = set () n = len ( self . raw_subtitles ) for i , line in enumerate ( self . raw_subtitles ): self . full_text_lines . append ( line ) if i in seen_i or \"-->\" in line : continue agg_line = \"\" if i < n - 1 and self . raw_subtitles [ i + 1 ] == \"\" : agg_line += line seen_i . add ( i ) self . aggregated_text_lines . append ( agg_line ) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i ]] # the following condition means that we are on the second part of a two lines subtitle text if i > 0 and i < n - 2 and self . raw_subtitles [ i + 2 ] == \"\" and self . raw_subtitles [ i - 1 ] != \"\" : seen_i . add ( i ) seen_i . add ( i + 1 ) agg_line += line + \" \" + self . raw_subtitles [ i + 1 ] self . aggregated_text_lines . append ( self . raw_subtitles [ i + 1 ]) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i , i + 1 ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i , i + 1 ]] def save_srt ( self , path : str | os . PathLike = \"translated.srt\" ) -> None : \"\"\"Save current subtitles into an srt files. If translate_subtitles was called before, this results in a translated srt file. Args: path (str | os.PathLike, optional): Path to the target SRT file. Defaults to \"translated.srt\". It is always saved, it is used to put back subtitles with FFmpeg. \"\"\" with open ( path , \"w\" , encoding = \"utf-8\" ) as file : for line in self . full_text_lines : # in Python we need to write blank lines manually (those in full_text_lines are skipped by default) if line == \"\" : file . write ( \" \\n \" ) else : file . write ( line ) file . write ( \" \\n \" )","title":"Subtitles"},{"location":"subtitles_reference/#subtitles_translator.subtitles.Subtitles.build_aggregated_dico","text":"After converting raw extraction to list of lines, aggregates and clean lines in order to be able to translate them. When two lines are combined, both indexes are saved in order to replace each line at the end. Source code in subtitles_translator/subtitles.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def build_aggregated_dico ( self ) -> None : \"\"\"After converting raw extraction to list of lines, aggregates and clean lines in order to be able to translate them. When two lines are combined, both indexes are saved in order to replace each line at the end. \"\"\" seen_i = set () n = len ( self . raw_subtitles ) for i , line in enumerate ( self . raw_subtitles ): self . full_text_lines . append ( line ) if i in seen_i or \"-->\" in line : continue agg_line = \"\" if i < n - 1 and self . raw_subtitles [ i + 1 ] == \"\" : agg_line += line seen_i . add ( i ) self . aggregated_text_lines . append ( agg_line ) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i ]] # the following condition means that we are on the second part of a two lines subtitle text if i > 0 and i < n - 2 and self . raw_subtitles [ i + 2 ] == \"\" and self . raw_subtitles [ i - 1 ] != \"\" : seen_i . add ( i ) seen_i . add ( i + 1 ) agg_line += line + \" \" + self . raw_subtitles [ i + 1 ] self . aggregated_text_lines . append ( self . raw_subtitles [ i + 1 ]) if agg_line in self . aggregated_dico_lines : self . aggregated_dico_lines [ agg_line ] . append ([ i , i + 1 ]) else : self . aggregated_dico_lines [ agg_line ] = [[ i , i + 1 ]]","title":"build_aggregated_dico()"},{"location":"subtitles_reference/#subtitles_translator.subtitles.Subtitles.save_srt","text":"Save current subtitles into an srt files. If translate_subtitles was called before, this results in a translated srt file. Parameters: Name Type Description Default path str | os . PathLike Path to the target SRT file. Defaults to \"translated.srt\". It is always saved, it is used to put back subtitles with FFmpeg. 'translated.srt' Source code in subtitles_translator/subtitles.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def save_srt ( self , path : str | os . PathLike = \"translated.srt\" ) -> None : \"\"\"Save current subtitles into an srt files. If translate_subtitles was called before, this results in a translated srt file. Args: path (str | os.PathLike, optional): Path to the target SRT file. Defaults to \"translated.srt\". It is always saved, it is used to put back subtitles with FFmpeg. \"\"\" with open ( path , \"w\" , encoding = \"utf-8\" ) as file : for line in self . full_text_lines : # in Python we need to write blank lines manually (those in full_text_lines are skipped by default) if line == \"\" : file . write ( \" \\n \" ) else : file . write ( line ) file . write ( \" \\n \" )","title":"save_srt()"},{"location":"translator_reference/","text":"Translator \u00b6 This class defines and stores a language model (such as MarianMT) for the translation task, from source_language to target_language. It also provides functions to perform full translations efficiently from extracted subtitles. Warning The translation model will be download from HugginFace servers and cached for a faster load next time. For each (source_language, target_language) pair, there is a distinct model. Parameters: Name Type Description Default source_language AvailableLanguages Language of the source subtitles. required target_language AvailableLanguages Target language. required Source code in subtitles_translator/translator.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class Translator : \"\"\"This class defines and stores a language model (such as MarianMT) for the translation task, from source_language to target_language. It also provides functions to perform full translations efficiently from extracted subtitles. Warning: The translation model will be download from HugginFace servers and cached for a faster load next time. For each (source_language, target_language) pair, there is a distinct model. Args: source_language (AvailableLanguages, optional): Language of the source subtitles. target_language (AvailableLanguages, optional): Target language. \"\"\" def __init__ ( self , source_language : AvailableLanguages , target_language : AvailableLanguages , ) -> None : self . source_language = source_language self . target_language = target_language model_name = f \"Helsinki-NLP/opus-mt- { source_language . value } - { target_language . value } \" self . tokenizer = AutoTokenizer . from_pretrained ( model_name ) self . model = AutoModelForSeq2SeqLM . from_pretrained ( model_name ) def translate ( self , input_text : str ) -> str : \"\"\"Translate a text input using the model. Args: input_text (str): Text to be translated (usually, a single sentence) Returns: str: Translated text. \"\"\" batch = self . tokenizer ([ input_text ], return_tensors = \"pt\" ) generated_ids = self . model . generate ( ** batch ) translated_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True )[ 0 ] return translated_text # type: ignore # noqa: PGH003 def translate_subtitles ( self , subtitles : Subtitles ) -> None : \"\"\"Use given translator to perform translation using dictionary of aggregated subtitles lines. Each translated line replaces the original one in the full_text_line list created at the beginning of the process. Args: subtitles (Subtitles object): Object of the Subtitles class. \"\"\" # here the iterable is aggregated_dico_lines.items(), we use progressBar for full_line_text , lines_ranges in self . progressBar ( iterable = subtitles . aggregated_dico_lines . items (), prefix = \"Progress:\" , suffix = \"Complete\" , length = 50 ): line_text = full_line_text . replace ( \" \\n \" , \"\" ) translated_text = self . translate ( line_text ) for line_pos in lines_ranges : # case when the current screen subtitles stands on 1 line if len ( line_pos ) == 1 : subtitles . full_text_lines [ line_pos [ 0 ]] = translated_text # case when we're on two lines subtitles # we try to \"rebuild\" two-line subtitles if len ( line_pos ) == 2 : split_text = translated_text . split ( \" \" ) mid_line = len ( split_text ) // 2 first_line = \" \" . join ( split_text [: mid_line ]) second_line = \" \" . join ( split_text [ mid_line :]) subtitles . full_text_lines [ line_pos [ 0 ]] = first_line subtitles . full_text_lines [ line_pos [ 1 ]] = second_line @staticmethod def progressBar ( iterable : Iterable [ tuple [ str , list ]], prefix : str = \"\" , suffix : str = \"\" , decimals : int = 1 , length : int = 100 , fill : str = \"\u2588\" , print_end : str = \" \\r \" , ) -> Generator [ tuple [ str , list ], None , None ]: \"\"\" Call in a loop to create terminal progress bar. Source : https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters/13685020 Args: iterable (Iterable): Iterable object prefix (str, optional): Prefix string suffix (str, optional): Suffix string decimals (int, optional): Positive number of decimals in percent complete length (int, optional) : Character length of bar fill (str, optional): Bar fill character (Str) print_end (str, optional): End character \"\"\" total = len ( iterable ) # type: ignore # type checks fails here (len of iterable ?) # noqa: PGH003 # Progress Bar Printing Function def printProgressBar ( iteration : int ) -> None : percent = ( \"{0:.\" + str ( decimals ) + \"f}\" ) . format ( 100 * ( iteration / float ( total ))) filledLength = int ( length * iteration // total ) bar = fill * filledLength + \"-\" * ( length - filledLength ) print ( f \" \\r { prefix } | { bar } | { percent } % { suffix } \" , end = print_end ) # Initial Call printProgressBar ( 0 ) # Update Progress Bar for i , item in enumerate ( iterable ): yield item printProgressBar ( i + 1 ) # Print New Line on Complete print () progressBar ( iterable , prefix = '' , suffix = '' , decimals = 1 , length = 100 , fill = '\u2588' , print_end = ' \\r ' ) staticmethod \u00b6 Call in a loop to create terminal progress bar. Source : https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters/13685020 Parameters: Name Type Description Default iterable Iterable Iterable object required prefix str Prefix string '' suffix str Suffix string '' decimals int Positive number of decimals in percent complete 1 length int, optional) Character length of bar 100 fill str Bar fill character (Str) '\u2588' print_end str End character '\\r' Source code in subtitles_translator/translator.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @staticmethod def progressBar ( iterable : Iterable [ tuple [ str , list ]], prefix : str = \"\" , suffix : str = \"\" , decimals : int = 1 , length : int = 100 , fill : str = \"\u2588\" , print_end : str = \" \\r \" , ) -> Generator [ tuple [ str , list ], None , None ]: \"\"\" Call in a loop to create terminal progress bar. Source : https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters/13685020 Args: iterable (Iterable): Iterable object prefix (str, optional): Prefix string suffix (str, optional): Suffix string decimals (int, optional): Positive number of decimals in percent complete length (int, optional) : Character length of bar fill (str, optional): Bar fill character (Str) print_end (str, optional): End character \"\"\" total = len ( iterable ) # type: ignore # type checks fails here (len of iterable ?) # noqa: PGH003 # Progress Bar Printing Function def printProgressBar ( iteration : int ) -> None : percent = ( \"{0:.\" + str ( decimals ) + \"f}\" ) . format ( 100 * ( iteration / float ( total ))) filledLength = int ( length * iteration // total ) bar = fill * filledLength + \"-\" * ( length - filledLength ) print ( f \" \\r { prefix } | { bar } | { percent } % { suffix } \" , end = print_end ) # Initial Call printProgressBar ( 0 ) # Update Progress Bar for i , item in enumerate ( iterable ): yield item printProgressBar ( i + 1 ) # Print New Line on Complete print () translate ( input_text ) \u00b6 Translate a text input using the model. Parameters: Name Type Description Default input_text str Text to be translated (usually, a single sentence) required Returns: Name Type Description str str Translated text. Source code in subtitles_translator/translator.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def translate ( self , input_text : str ) -> str : \"\"\"Translate a text input using the model. Args: input_text (str): Text to be translated (usually, a single sentence) Returns: str: Translated text. \"\"\" batch = self . tokenizer ([ input_text ], return_tensors = \"pt\" ) generated_ids = self . model . generate ( ** batch ) translated_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True )[ 0 ] return translated_text # type: ignore # noqa: PGH003 translate_subtitles ( subtitles ) \u00b6 Use given translator to perform translation using dictionary of aggregated subtitles lines. Each translated line replaces the original one in the full_text_line list created at the beginning of the process. Parameters: Name Type Description Default subtitles Subtitles object Object of the Subtitles class. required Source code in subtitles_translator/translator.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def translate_subtitles ( self , subtitles : Subtitles ) -> None : \"\"\"Use given translator to perform translation using dictionary of aggregated subtitles lines. Each translated line replaces the original one in the full_text_line list created at the beginning of the process. Args: subtitles (Subtitles object): Object of the Subtitles class. \"\"\" # here the iterable is aggregated_dico_lines.items(), we use progressBar for full_line_text , lines_ranges in self . progressBar ( iterable = subtitles . aggregated_dico_lines . items (), prefix = \"Progress:\" , suffix = \"Complete\" , length = 50 ): line_text = full_line_text . replace ( \" \\n \" , \"\" ) translated_text = self . translate ( line_text ) for line_pos in lines_ranges : # case when the current screen subtitles stands on 1 line if len ( line_pos ) == 1 : subtitles . full_text_lines [ line_pos [ 0 ]] = translated_text # case when we're on two lines subtitles # we try to \"rebuild\" two-line subtitles if len ( line_pos ) == 2 : split_text = translated_text . split ( \" \" ) mid_line = len ( split_text ) // 2 first_line = \" \" . join ( split_text [: mid_line ]) second_line = \" \" . join ( split_text [ mid_line :]) subtitles . full_text_lines [ line_pos [ 0 ]] = first_line subtitles . full_text_lines [ line_pos [ 1 ]] = second_line","title":"Translator Class"},{"location":"translator_reference/#subtitles_translator.translator.Translator","text":"This class defines and stores a language model (such as MarianMT) for the translation task, from source_language to target_language. It also provides functions to perform full translations efficiently from extracted subtitles. Warning The translation model will be download from HugginFace servers and cached for a faster load next time. For each (source_language, target_language) pair, there is a distinct model. Parameters: Name Type Description Default source_language AvailableLanguages Language of the source subtitles. required target_language AvailableLanguages Target language. required Source code in subtitles_translator/translator.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class Translator : \"\"\"This class defines and stores a language model (such as MarianMT) for the translation task, from source_language to target_language. It also provides functions to perform full translations efficiently from extracted subtitles. Warning: The translation model will be download from HugginFace servers and cached for a faster load next time. For each (source_language, target_language) pair, there is a distinct model. Args: source_language (AvailableLanguages, optional): Language of the source subtitles. target_language (AvailableLanguages, optional): Target language. \"\"\" def __init__ ( self , source_language : AvailableLanguages , target_language : AvailableLanguages , ) -> None : self . source_language = source_language self . target_language = target_language model_name = f \"Helsinki-NLP/opus-mt- { source_language . value } - { target_language . value } \" self . tokenizer = AutoTokenizer . from_pretrained ( model_name ) self . model = AutoModelForSeq2SeqLM . from_pretrained ( model_name ) def translate ( self , input_text : str ) -> str : \"\"\"Translate a text input using the model. Args: input_text (str): Text to be translated (usually, a single sentence) Returns: str: Translated text. \"\"\" batch = self . tokenizer ([ input_text ], return_tensors = \"pt\" ) generated_ids = self . model . generate ( ** batch ) translated_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True )[ 0 ] return translated_text # type: ignore # noqa: PGH003 def translate_subtitles ( self , subtitles : Subtitles ) -> None : \"\"\"Use given translator to perform translation using dictionary of aggregated subtitles lines. Each translated line replaces the original one in the full_text_line list created at the beginning of the process. Args: subtitles (Subtitles object): Object of the Subtitles class. \"\"\" # here the iterable is aggregated_dico_lines.items(), we use progressBar for full_line_text , lines_ranges in self . progressBar ( iterable = subtitles . aggregated_dico_lines . items (), prefix = \"Progress:\" , suffix = \"Complete\" , length = 50 ): line_text = full_line_text . replace ( \" \\n \" , \"\" ) translated_text = self . translate ( line_text ) for line_pos in lines_ranges : # case when the current screen subtitles stands on 1 line if len ( line_pos ) == 1 : subtitles . full_text_lines [ line_pos [ 0 ]] = translated_text # case when we're on two lines subtitles # we try to \"rebuild\" two-line subtitles if len ( line_pos ) == 2 : split_text = translated_text . split ( \" \" ) mid_line = len ( split_text ) // 2 first_line = \" \" . join ( split_text [: mid_line ]) second_line = \" \" . join ( split_text [ mid_line :]) subtitles . full_text_lines [ line_pos [ 0 ]] = first_line subtitles . full_text_lines [ line_pos [ 1 ]] = second_line @staticmethod def progressBar ( iterable : Iterable [ tuple [ str , list ]], prefix : str = \"\" , suffix : str = \"\" , decimals : int = 1 , length : int = 100 , fill : str = \"\u2588\" , print_end : str = \" \\r \" , ) -> Generator [ tuple [ str , list ], None , None ]: \"\"\" Call in a loop to create terminal progress bar. Source : https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters/13685020 Args: iterable (Iterable): Iterable object prefix (str, optional): Prefix string suffix (str, optional): Suffix string decimals (int, optional): Positive number of decimals in percent complete length (int, optional) : Character length of bar fill (str, optional): Bar fill character (Str) print_end (str, optional): End character \"\"\" total = len ( iterable ) # type: ignore # type checks fails here (len of iterable ?) # noqa: PGH003 # Progress Bar Printing Function def printProgressBar ( iteration : int ) -> None : percent = ( \"{0:.\" + str ( decimals ) + \"f}\" ) . format ( 100 * ( iteration / float ( total ))) filledLength = int ( length * iteration // total ) bar = fill * filledLength + \"-\" * ( length - filledLength ) print ( f \" \\r { prefix } | { bar } | { percent } % { suffix } \" , end = print_end ) # Initial Call printProgressBar ( 0 ) # Update Progress Bar for i , item in enumerate ( iterable ): yield item printProgressBar ( i + 1 ) # Print New Line on Complete print ()","title":"Translator"},{"location":"translator_reference/#subtitles_translator.translator.Translator.progressBar","text":"Call in a loop to create terminal progress bar. Source : https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters/13685020 Parameters: Name Type Description Default iterable Iterable Iterable object required prefix str Prefix string '' suffix str Suffix string '' decimals int Positive number of decimals in percent complete 1 length int, optional) Character length of bar 100 fill str Bar fill character (Str) '\u2588' print_end str End character '\\r' Source code in subtitles_translator/translator.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @staticmethod def progressBar ( iterable : Iterable [ tuple [ str , list ]], prefix : str = \"\" , suffix : str = \"\" , decimals : int = 1 , length : int = 100 , fill : str = \"\u2588\" , print_end : str = \" \\r \" , ) -> Generator [ tuple [ str , list ], None , None ]: \"\"\" Call in a loop to create terminal progress bar. Source : https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters/13685020 Args: iterable (Iterable): Iterable object prefix (str, optional): Prefix string suffix (str, optional): Suffix string decimals (int, optional): Positive number of decimals in percent complete length (int, optional) : Character length of bar fill (str, optional): Bar fill character (Str) print_end (str, optional): End character \"\"\" total = len ( iterable ) # type: ignore # type checks fails here (len of iterable ?) # noqa: PGH003 # Progress Bar Printing Function def printProgressBar ( iteration : int ) -> None : percent = ( \"{0:.\" + str ( decimals ) + \"f}\" ) . format ( 100 * ( iteration / float ( total ))) filledLength = int ( length * iteration // total ) bar = fill * filledLength + \"-\" * ( length - filledLength ) print ( f \" \\r { prefix } | { bar } | { percent } % { suffix } \" , end = print_end ) # Initial Call printProgressBar ( 0 ) # Update Progress Bar for i , item in enumerate ( iterable ): yield item printProgressBar ( i + 1 ) # Print New Line on Complete print ()","title":"progressBar()"},{"location":"translator_reference/#subtitles_translator.translator.Translator.translate","text":"Translate a text input using the model. Parameters: Name Type Description Default input_text str Text to be translated (usually, a single sentence) required Returns: Name Type Description str str Translated text. Source code in subtitles_translator/translator.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def translate ( self , input_text : str ) -> str : \"\"\"Translate a text input using the model. Args: input_text (str): Text to be translated (usually, a single sentence) Returns: str: Translated text. \"\"\" batch = self . tokenizer ([ input_text ], return_tensors = \"pt\" ) generated_ids = self . model . generate ( ** batch ) translated_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True )[ 0 ] return translated_text # type: ignore # noqa: PGH003","title":"translate()"},{"location":"translator_reference/#subtitles_translator.translator.Translator.translate_subtitles","text":"Use given translator to perform translation using dictionary of aggregated subtitles lines. Each translated line replaces the original one in the full_text_line list created at the beginning of the process. Parameters: Name Type Description Default subtitles Subtitles object Object of the Subtitles class. required Source code in subtitles_translator/translator.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def translate_subtitles ( self , subtitles : Subtitles ) -> None : \"\"\"Use given translator to perform translation using dictionary of aggregated subtitles lines. Each translated line replaces the original one in the full_text_line list created at the beginning of the process. Args: subtitles (Subtitles object): Object of the Subtitles class. \"\"\" # here the iterable is aggregated_dico_lines.items(), we use progressBar for full_line_text , lines_ranges in self . progressBar ( iterable = subtitles . aggregated_dico_lines . items (), prefix = \"Progress:\" , suffix = \"Complete\" , length = 50 ): line_text = full_line_text . replace ( \" \\n \" , \"\" ) translated_text = self . translate ( line_text ) for line_pos in lines_ranges : # case when the current screen subtitles stands on 1 line if len ( line_pos ) == 1 : subtitles . full_text_lines [ line_pos [ 0 ]] = translated_text # case when we're on two lines subtitles # we try to \"rebuild\" two-line subtitles if len ( line_pos ) == 2 : split_text = translated_text . split ( \" \" ) mid_line = len ( split_text ) // 2 first_line = \" \" . join ( split_text [: mid_line ]) second_line = \" \" . join ( split_text [ mid_line :]) subtitles . full_text_lines [ line_pos [ 0 ]] = first_line subtitles . full_text_lines [ line_pos [ 1 ]] = second_line","title":"translate_subtitles()"}]}